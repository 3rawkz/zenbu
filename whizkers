#!/usr/bin/env python2

description = """
A pystache + YAML based config templater.

Searches for an optional yaml file with a variable mapping in
~/.config/whizkers/variables.yaml,

an optional yaml file with an ignore scalar in (by default)
~/.config/whizkers/ignores.yaml,

and uses the templates in (by default)
~/.config/whizkers/templates/

to render into your home directory (by default).

Additional variable files can be applied
by supplying them as arguments, in order of application.

They can either be paths or, if located in
~/.config/whizkers/variable_sets/,
extension-less filenames.

Environment variable support is available;
simply put the name of the variable in mustache brackets.

Finally, diffs between the current destination files and
template renderings are available via command-line flag.
"""

import os
import codecs
import yaml
import re
from sys import exit
from difflib import unified_diff
from argparse import ArgumentParser
from termcolor import cprint
from pystache.renderer import Renderer
from pystache.common import MissingTags
from pystache.context import KeyNotFoundError


HOME = os.getenv('HOME')
CONFIG_DIR = os.getenv(
    'XDG_CONFIG_HOME',
    os.path.join(HOME, '.config'))
WHIZKERS_ROOT = os.path.join(
    CONFIG_DIR, 'whizkers')
WHIZKERS_DEFAULTS = os.path.join(
    WHIZKERS_ROOT, 'defaults.yaml')
WHIZKERS_VAR_SETS = os.path.join(
    WHIZKERS_ROOT, 'variable_sets')
WHIZKERS_IGNORES = os.path.join(
    WHIZKERS_ROOT, 'ignores.yaml')
WHIZKERS_TEMPLATES = os.path.join(
    WHIZKERS_ROOT, 'templates')
TEMPLATE_EXT = 'yaml'


def make_dirs_and_open(path):
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    return codecs.open(path, 'w', 'utf-8')

def diff_print(line):
    if re.match('^(===|---|\+\+\+|@@)', line):
        cprint(line.encode('utf-8'), attrs=['bold'])
    elif re.match('^\+', line):
        cprint(line.encode('utf-8'), 'green')
    elif re.match('^-', line):
        cprint(line.encode('utf-8'), 'red')
    elif re.match('^\?', line):
        cprint(line.encode('utf-8'), 'yellow')
    else:
        print(line.encode('utf-8'))

class DetailException(Exception):
    def __init__(self, message, path):
        super(DetailError, self).__init__(message)
        self.path = path


class FileNotFoundError(Detai:
        msg = "Was not found: \"%s\"" % self.path
        if self.message:
            msg += " (%s)" % self.message
        return msg


class FileParseError(DetailException):
    def __str__(self):
        msg = "Could not parse: \"%s\"" % self.path
        if self.message:
            msg += " (%s)" % self.message
        return msg

class RenderError(DetailException):
    def __str__(self):
        msg = "Could not render: \"%s\"" % self.path
        if self.message:
            msg += " (%s)" % self.message
        return msg


class Whizker:
    def __init__(self,
                 templates_path,
                 dest_path,
                 var_set_path=None,
                 use_env_vars=False,
                 variables=[],
                 ignores=None):
        self.variables = {}     # {variable: value}
        self.ignores = set()    # Set of regexes

        self.renderer = Renderer(
            missing_tags=MissingTags.strict,    # Alert on missing vars
            escape=lambda x: x,                 # Don't escape
        )

        if os.path.exists(templates_path):
            self.templates_path = templates_path
        else:
            raise FileNotFoundException(path=templates_path)

        if os.path.exists(dest_path):
            self.dest_path = dest_path
        else:
            raise FileNotFoundException(path=dest_path)

        if not var_set_path or os.path.exists(var_set_path):
            self.var_set_path = var_set_path
        else:
            raise FileNotFoundException(path=var_set_path)

        # Initial setup
        if use_env_vars:
            self.variables.update(dict(os.environ))
        for name in variables:
            self.add_variables(name)
        if ignores:
            self.add_ignores(ignores)

    def add_variables(self, name):
        # If it might be just a name...
        if not os.path.isfile(name):
            name = os.path.join(WHIZKERS_VAR_SETS, '%s.yaml' % name)

        try:
            with codecs.open(name, 'r', 'utf-8') as f:
                to_merge = yaml.load(f.read())
        except IOError:
            raise FileNotFoundError(path=name)
        except yaml.parser.ParserError:
            raise FileParseError(path=name)
        else:
            if isinstance(to_merge, dict):
                self.variables.update(to_merge)
            else:
                raise FileParseError("not in mapping format", path=name)

    def add_ignores(self, filename):
        try:
            with codecs.open(filename, 'r', 'utf-8') as f:
                to_merge = yaml.load(f.read())
        except IOError:
            raise FileNotFoundError(path=filename)
        except yaml.parser.ParserError:
            raise FileParseError(path=filename)
        else:
            if isinstance(to_merge, list):
                self.ignores |= set(re.compile(i) for i in to_merge)
            else:
                raise FileParseError("not in scalar format", path=filename)

    def should_ignore(self, name):
        for pattern in self.ignores:
            if pattern.match(name):
                return True
        return False

    @property
    def var_sets(self):
        """
        Yield the available variable sets
        """
        # Does our folder exist?
        if self.var_set_path:

            # Get all the paths...
            for name in os.listdir(self.var_set_path):
                if not self.should_ignore(name):
                    path = os.path.join(self.var_set_path, name)
                    if os.path.isfile(path):
                        yield re.sub('\.%s$' % TEMPLATE_EXT, '', name)
        else:
            raise FileNotFoundError(path=self.var_set_path)

    @property
    def render_pairs(self):
        """
        Yield pairs of (template, destination file)
        """
        for root, subdirs, files in os.walk(self.templates_path):

            # Substitute the template dir for home dir
            dest_root = re.sub('^%s' % self.templates_path,
                               self.dest_path, root)

            # Iterate through templates
            for name in files:
                if not self.should_ignore(name):
                    template = os.path.join(root, name)
                    dest = os.path.join(dest_root, name)
                    yield (template, dest)

    def pre_render(self):
        """
        Yield pairs of (destination file, what to write)
        """
        for template, dest in self.render_pairs:
            try:
                with codecs.open(template, 'r', 'utf-8') as f:
                    yield (dest, self.renderer.render(
                        f.read(), self.variables))
            except KeyNotFoundError as e:
                raise RenderError(e.message, path=template)

    def render(self):
        for dest, applied in self.pre_render():
            # Delete any existing file first
            try:
                os.remove(dest)
            except OSError:
                pass

            with make_dirs_and_open(dest) as f:
                f.write(applied)

    def diff(self):
        for dest, applied in self.pre_render():
            try:
                with codecs.open(dest, 'r', 'utf-8') as f:
                    yield unified_diff(
                        f.readlines(), applied.splitlines(True),
                        fromfile='%s (rendered)' % dest_file,
                        tofile=dest_file)
            except IOError:
                yield ["=== No destination file \"%s\" for comparison.\n" %
                       dest]

def parse_args():
    parser = ArgumentParser(description=description)
    parser.add_argument('-l',
                        help="""
                        list variable sets.
                        """,
                        dest='list_var_sets',
                        action='store_true',
                        default=False)
    parser.add_argument('-t',
                        help="""
                        template directory.
                        Default: %s
                        """ % WHIZKERS_TEMPLATES,
                        dest='template_dir',
                        type=str,
                        default=WHIZKERS_TEMPLATES)
    parser.add_argument('-d',
                        help="""
                        destination directory.
                        Default: %s
                        """ % HOME,
                        dest='dest_dir',
                        type=str,
                        default=HOME)
    parser.add_argument('-i',
                        help="""
                        ignores file.
                        Default: %s
                        """ % WHIZKERS_IGNORES,
                        dest='ignores_file',
                        type=str,
                        default=WHIZKERS_IGNORES)
    parser.add_argument('-e',
                        help="""
                        whether or not to use environment variables.
                        Default: don't use environment variables
                        """,
                        dest='env_vars',
                        action='store_true',
                        default=False)
    parser.add_argument('--diff',
                        help="""
                        show diff between template renderings and current
                        destination files
                        """,
                        action='store_true',
                        default=False)
    parser.add_argument('variable_files',
                        help="additional variable files",
                        nargs='*',
                        type=str)
    return parser.parse_args()


def main():
    args = parse_args()
    errs = False
    variables = {}
    ignores = set()

    renderer = Renderer(
        missing_tags=MissingTags.strict,    # Alert on missing vars
        escape=lambda x: x,                 # Don't escape
    )

    # How to update variables - returns success
    def update_variables(variables, filename):
        with codecs.open(filename, 'r', 'utf-8') as f:
            try:
                to_merge = yaml.load(f.read())
            except yaml.parser.ParserError:
                cprint("\"%s\" could not be parsed." % filename, 'red')
                return False
            else:
                if isinstance(to_merge, dict):
                    variables.update(to_merge)
                    print("Using \"%s\"..." % filename)
                    return True
                else:
                    cprint("\"%s\" was not in mapping format." %
                           filename, 'red')
                    return False

    # Read ignores file
    try:
        with codecs.open(args.ignores_file, 'r', 'utf-8') as f:
            to_merge = yaml.load(f.read())
        if isinstance(to_merge, list):
            ignores |= set(to_merge)
        else:
            cprint("\"%s\" was not in scalar format." %
                   args.ignores_file, 'red')
            errs = True
    except IOError:
        cprint("No ignores file found. Skipping...", 'yellow')

    # Pre-compile regexes
    ignores = [re.compile(i) for i in ignores]

    # Did we request a listing of variable sets?
    if args.list_var_sets:

        # Does our folder exist?
        if os.path.exists(WHIZKERS_VAR_SETS):

            # Get all the paths...
            for name in os.listdir(WHIZKERS_VAR_SETS):
                path = os.path.join(WHIZKERS_VAR_SETS, name)
                if os.path.isfile(path):

                    # Check if we should ignore it
                    ignore = False

                    for pattern in ignores:
                        if pattern.match(name):
                            ignore = True
                            break

                    if not ignore:
                        print(re.sub('\.yaml$', '', name))
        else:
            cprint("Variable sets folder %s not found." % WHIZKERS_VAR_SETS,
                   'yellow')
        exit(0)

    # Use environment variables if requested
    if args.env_vars:
        print("Using environment variables...")
        variables.update(dict(os.environ))

    # Read the config
    try:
        errs |= not update_variables(variables, WHIZKERS_DEFAULTS)
    except IOError:
        cprint("No default variables file found. Skipping...", 'yellow')

    # Read additional files
    for name in args.variable_files:
        try:
            errs |= not update_variables(variables, name)
        except IOError:

            # Try opening just by name
            name = os.path.join(WHIZKERS_VAR_SETS, '%s.yaml' % name)
            try:
                errs |= not update_variables(variables, name)
            except IOError:
                cprint("Variable file %s not found." % name, 'red')
                errs = True

    if not variables:
        cprint("No variables provided.", 'red')
        errs = True

    # Errors?
    if errs:
        cprint("\nErrors occurred - abort.", 'red')
        exit(1)

    # Exit code, in case one of the templates doesn't render
    exit_code = 0

    if args.diff:
        cprint("\nShowing diffs...", attrs=['underline'])

    # Loop through the templates
    for root, subdirs, files in os.walk(args.template_dir):

        # Substitute the template dir for home dir
        dest_root = re.sub('^%s' % args.template_dir,
                           args.dest_dir, root)

        # Iterate through templates
        for name in files:
            ignore = False

            # Check ignore list
            for pattern in ignores:
                if pattern.match(name):
                    ignore = True
                    break

            if ignore:
                continue

            template = os.path.join(root, name)
            dest_file = os.path.join(dest_root, name)

            # Make the directory
            if not os.path.exists(dest_root):
                os.makedirs(dest_root)

            # Apply variables
            try:
                with codecs.open(template, 'r', 'utf-8') as f:
                    applied = renderer.render(f.read(), variables)
            except KeyNotFoundError as e:
                # Add a newline if we're doing diffs
                if args.diff:
                    print('')
                cprint("Render error in \"%s\":" % template, 'red')
                cprint("    %s" % e, 'red')
                exit_code = 1
            else:
                if args.diff:
                    try:
                        with codecs.open(dest_file, 'r', 'utf-8') as f:
                            diff = unified_diff(
                                f.readlines(), applied.splitlines(True),
                                fromfile='%s (rendered)' % dest_file,
                                tofile=dest_file)
                    # File missing
                    except IOError:
                        cprint(
                            '\nNo destination file \"%s\" for comparison.' %
                            dest_file, 'yellow')
                    else:
                        firstline = True
                        for line in diff:
                            if firstline:
                                print('')
                                firstline = False
                            line = line.rstrip('\n')
                            if re.match('^(---|\+\+\+|@@)', line):
                                cprint(line.encode('utf-8'), attrs=['bold'])
                            elif re.match('^\+', line):
                                cprint(line.encode('utf-8'), 'green')
                            elif re.match('^-', line):
                                cprint(line.encode('utf-8'), 'red')
                            elif re.match('^\?', line):
                                cprint(line.encode('utf-8'), 'yellow')
                            else:
                                print(line.encode('utf-8'))

                # Render
                else:
                    # Delete any existing file first
                    try:
                        os.remove(dest_file)
                    except OSError:
                        pass

                    with codecs.open(dest_file, 'w', 'utf-8') as f:
                        f.write(applied)
                    cprint("Successfully rendered %s." % template, 'green')

    exit(exit_code)

if __name__ == '__main__':
    main()

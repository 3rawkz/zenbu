#!/usr/bin/env python2

description = """
A pystache + YAML based config templater.

Searches for an optional yaml file with a variable mapping in
~/.config/whizkers/variables.yaml,

an optional yaml file with an ignore scalar in (by default)
~/.config/whizkers/ignores.yaml,

and uses the templates in (by default)
~/.config/whizkers/templates/

to render into your home directory (by default).

Additional variable files can be applied
by supplying them as arguments, in order of application.

They can either be paths or, if located in (by default)
~/.config/whizkers/variable_sets/,
extension-less filenames.

Environment variable support is available;
simply put the name of the variable in mustache brackets.

Finally, diffs between the current destination files and
template renderings are available via command-line flag.
"""

import logging
import os
import codecs
import yaml
import re
from sys import exit, stdout
from difflib import unified_diff
from argparse import ArgumentParser
from termcolor import cprint
from colorlog import ColoredFormatter
from pystache.renderer import Renderer
from pystache.common import MissingTags
from pystache.context import KeyNotFoundError


# Constants
HOME = os.getenv('HOME')
CONFIG_DIR = os.getenv(
    'XDG_CONFIG_HOME',
    os.path.join(HOME, '.config'))
WHIZKERS_ROOT = os.path.join(
    CONFIG_DIR, 'whizkers')
WHIZKERS_DEFAULTS = os.path.join(
    WHIZKERS_ROOT, 'defaults.yaml')
WHIZKERS_VAR_SETS = os.path.join(
    WHIZKERS_ROOT, 'variable_sets')
WHIZKERS_IGNORES = os.path.join(
    WHIZKERS_ROOT, 'ignores.yaml')
WHIZKERS_TEMPLATES = os.path.join(
    WHIZKERS_ROOT, 'templates')
TEMPLATE_EXT = 'yaml'

# Logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)
logger.addHandler(logging.NullHandler())

# Convenience functions
def make_dirs_and_open(path):
    if not os.path.exists(os.path.dirname(path)):
        os.makedirs(os.path.dirname(path))
    return codecs.open(path, 'w', 'utf-8')

def diff_print(line):
    line = line.rstrip('\n')
    if re.match('^(===|---|\+\+\+|@@)', line):
        cprint(line.encode('utf-8'), attrs=['bold'])
    elif re.match('^\+', line):
        cprint(line.encode('utf-8'), 'green')
    elif re.match('^-', line):
        cprint(line.encode('utf-8'), 'red')
    elif re.match('^\?', line):
        cprint(line.encode('utf-8'), 'yellow')
    else:
        print(line.encode('utf-8'))


# Exceptions
class PathException(Exception):
    def __init__(self, path, message=None):
        super(PathException, self).__init__(message)
        self.path = path


class FileNotFoundError(PathException):
    def __str__(self):
        msg = "Was not found: \"%s\"" % self.path
        if self.message:
            msg += "\n    (%s)" % self.message
        return msg


class FileParseError(PathException):
    def __str__(self):
        msg = "Could not parse: \"%s\"" % self.path
        if self.message:
            msg += "\n    (%s)" % self.message
        return msg

class FileRenderError(PathException):
    def __str__(self):
        msg = "Could not render: \"%s\"" % self.path
        if self.message:
            msg += "\n    (%s)" % self.message
        return msg


class Whizker:
    """
    A template manager.
    """
    def __init__(self,
                 templates_path,
                 dest_path,
                 var_set_path=None,
                 use_env_vars=False,
                 variables=[],
                 ignores=None):
        self.variables = {}     # {variable: value}
        self.ignores = set()    # Set of regexes

        self.renderer = Renderer(
            missing_tags=MissingTags.strict,    # Alert on missing vars
            escape=lambda x: x,                 # Don't escape
        )

        # Check paths
        if os.path.exists(templates_path):
            self.templates_path = templates_path
        else:
            raise FileNotFoundError(templates_path, "templates path")

        if os.path.exists(dest_path):
            self.dest_path = dest_path
        else:
            raise FileNotFoundError(dest_path, "destination path")

        if not var_set_path or os.path.exists(var_set_path):
            self.var_set_path = var_set_path
        else:
            raise FileNotFoundError(var_set_path, "variable set path")

        # Initial setup
        if use_env_vars:
            self.variables.update(dict(os.environ))
        for name in variables:
            self.add_variables(name)
        if ignores:
            self.add_ignores(ignores)

    def add_variables(self, name):
        # If it might be just a name...
        if self.var_set_path and not os.path.exists(name):
            name = os.path.join(self.var_set_path, '%s.yaml' % name)

        try:
            with codecs.open(name, 'r', 'utf-8') as f:
                to_merge = yaml.load(f.read())
        except IOError:
            raise FileNotFoundError(name, "variables file")
        except yaml.parser.ParserError as e:
            raise FileParseError(name, e)
        else:
            if isinstance(to_merge, dict):
                logger.info("Using \"%s\"..." % name)
                self.variables.update(to_merge)
            else:
                raise FileParseError(name, "not in mapping format")

    def add_ignores(self, name):
        try:
            with codecs.open(name, 'r', 'utf-8') as f:
                to_merge = yaml.load(f.read())
        except IOError:
            raise FileNotFoundError(name, "ignores file")
        except yaml.parser.ParserError as e:
            raise FileParseError(e, name)
        else:
            if isinstance(to_merge, list):
                self.ignores |= set(re.compile(i) for i in to_merge)
            else:
                raise FileParseError(name, "not in scalar format")

    def should_ignore(self, name):
        """
        Check if a name should be ignored according to self.ignores
        """
        for pattern in self.ignores:
            if pattern.match(name):
                return True
        return False

    @property
    def var_sets(self):
        """
        Yield the available variable sets
        """
        # Does our folder exist?
        if self.var_set_path:

            # Get all the paths...
            for name in os.listdir(self.var_set_path):
                if not self.should_ignore(name):
                    path = os.path.join(self.var_set_path, name)
                    if os.path.isfile(path):
                        # Yield without .yaml
                        yield re.sub('\.%s$' % TEMPLATE_EXT, '', name)
        else:
            raise ValueError("No variable set path to list from.")

    @property
    def render_pairs(self):
        """
        Yield pairs of (template file, destination file)
        """
        for root, subdirs, files in os.walk(self.templates_path):

            # Substitute the template dir for home dir
            dest_root = re.sub('^%s' % self.templates_path,
                               self.dest_path, root)

            # Iterate through templates
            for name in files:
                if not self.should_ignore(name):
                    template = os.path.join(root, name)
                    dest = os.path.join(dest_root, name)
                    yield (template, dest)

    def pre_render(self):
        """
        Yield pairs of (destination file, what to write)
        or if there is an error, (destination file, FileRenderError)
        """
        for template, dest in self.render_pairs:
            try:
                with codecs.open(template, 'r', 'utf-8') as f:
                    yield (dest, self.renderer.render(
                        f.read(), self.variables))
            except KeyNotFoundError as e:
                yield (dest, FileRenderError(template, e))

    def render(self):
        """
        Only logs in the case of file render errors.
        """
        for dest, result in self.pre_render():
            if isinstance(result, FileRenderError):
                logger.error(result)
            else:
                # Delete any existing file first
                try:
                    os.remove(dest)
                except OSError:
                    pass

                with make_dirs_and_open(dest) as f:
                    f.write(result)
                    logger.info("Successfully rendered \"%s\"" % dest)

    def diff(self):
        """
        Only logs in the case of file render errors.
        """
        for dest, result in self.pre_render():
            if isinstance(result, FileRenderError):
                logger.error(result)
            else:
                try:
                    with codecs.open(dest, 'r', 'utf-8') as f:
                        yield unified_diff(
                            result.splitlines(True),
                            f.readlines(),
                            fromfile=dest,
                            tofile='%s (rendered)' % dest)
                except IOError:
                    yield [
                        "=== No destination file \"%s\" for comparison.\n"
                        % dest]

def parse_args():
    parser = ArgumentParser(description=description)

    parser.add_argument('-l',
                        help="""
                        list variable sets.
                        """,
                        dest='list_var_sets',
                        action='store_true',
                        default=False)

    parser.add_argument('-t',
                        help="""
                        template directory.
                        Default: %s
                        """ % WHIZKERS_TEMPLATES,
                        dest='template_dir',
                        type=str,
                        default=WHIZKERS_TEMPLATES)

    parser.add_argument('-d',
                        help="""
                        destination directory.
                        Default: %s
                        """ % HOME,
                        dest='dest_dir',
                        type=str,
                        default=HOME)

    parser.add_argument('-s',
                        help="""
                        variable set directory.
                        Default: %s
                        """ % WHIZKERS_VAR_SETS,
                        dest='var_set_dir',
                        type=str,
                        default=WHIZKERS_VAR_SETS)

    parser.add_argument('-i',
                        help="""
                        ignores file.
                        Default: %s
                        """ % WHIZKERS_IGNORES,
                        dest='ignores_file',
                        type=str,
                        default=WHIZKERS_IGNORES)

    parser.add_argument('-e',
                        help="""
                        whether or not to use environment variables.
                        Default: don't use environment variables
                        """,
                        dest='env_vars',
                        action='store_true',
                        default=False)

    parser.add_argument('--diff',
                        help="""
                        show diff between template renderings and current
                        destination files
                        """,
                        action='store_true',
                        default=False)

    parser.add_argument('variable_files',
                        help="additional variable files",
                        nargs='*',
                        type=str)

    return parser.parse_args()


def main():
    args = parse_args()

    # Set up logging
    ch = logging.StreamHandler(stdout)
    ch.setLevel(logging.DEBUG)
    ch.setFormatter(ColoredFormatter("%(log_color)s%(message)s"))
    logger.addHandler(ch)

    # Defaults on files
    if args.list_var_sets:
        args.variable_files = []
    elif os.path.isfile(WHIZKERS_DEFAULTS):
        args.variable_files.insert(0, WHIZKERS_DEFAULTS)
    else:
        logger.warn("Default variables file %s not found. Skipping..."
                    % WHIZKERS_DEFAULTS)

    if not os.path.isfile(args.ignores_file):
        logger.warn("Ignores file %s not found. Skipping..."
                    % args.ignores_file)
        args.ignores_file = None

    try:
        whizker = Whizker(
            args.template_dir,
            args.dest_dir,
            args.var_set_dir,
            args.env_vars,
            args.variable_files,
            args.ignores_file
        )
    except (FileNotFoundError, FileParseError) as e:
        logger.critical(e)
        exit(1)

    if args.list_var_sets:
        try:
            for var_set in whizker.var_sets:
                print(var_set)
        except ValueError as e:
            logger.critical(e)
            exit(1)

    elif args.diff:
        for diff in whizker.diff():
            for line in diff:
                diff_print(line)

    else:
        whizker.render()

if __name__ == '__main__':
    main()
